local Str = require 'std.string'
local O = require 'std.object'
local C = terralib.includecstring [[#include <string.h>]]

describe("string", function()
  it("should have a default constructor", terra()
    var s : Str
    O.new(s)
    assert.equal(s.s, nil)
  end)
  it("should have a string copy constructor", terra()
    var s : Str
    O.new(s, "test")
    assert.equal(C.strcmp(s.s, "test"), 0)
  end)
  it("should have an explicit length constructor", terra()
    var s : Str
    O.new(s, "test", 3)
    assert.equal(C.strcmp(s.s, "tes"), 0)
  end)
  it("should replace characters", terra()
    var s = O.new(Str, "abcdefg")
    s:replace(("c")[0], ("z")[0])
    assert.equal(C.strcmp(s.s, "abzdefg"), 0)
    s:replace(("a")[0], ("w")[0])
    assert.equal(C.strcmp(s.s, "wbzdefg"), 0)
    s:replace(("g")[0], ("i")[0])
    assert.equal(C.strcmp(s.s, "wbzdefi"), 0)
  end)
  it("should concatenate properly", terra()
    var s = Str.Concat("foo", "bar")
    assert.equal(C.strcmp(s.s, "foobar"), 0)
    var s2 = Str.Concat(s, "!")
    assert.equal(C.strcmp(s2.s, "foobar!"), 0)
    var s3 = Str.Concat("> ", s2)
    assert.equal(C.strcmp(s3.s, "> foobar!"), 0)
  end)
  it("should append properly", terra()
    var s = O.new(Str, "foo")
    assert.equal(C.strcmp(s:append("bar").s, "foobar"), 0)
  end)
  it("should be convertible to rawstring", terra()
    var s : rawstring = O.new(Str, "foobars")
    assert.equal(C.strcmp(s, "foobars"), 0)
  end)
  it("can be added together", terra()
    var s = O.new(Str, "foo") + "bar" + "s" + O.new(Str, "!")
    assert.equal(C.strcmp(s.s, "foobars!"), 0)
  end)
  it("can be compared with other strings", terra()
    var empty = O.new(Str)
    assert.is_true(empty == empty)
    assert.is_false(empty ~= empty)
    assert.is_false(empty == "")
    assert.is_true(empty ~= "")
    assert.is_true(O.new(Str, "foo") == "foo")
    assert.is_false(O.new(Str, "foo") == "food")
    assert.is_true(O.new(Str, "foo") == O.new(Str, "foo"))
    assert.is_false(O.new(Str, "foo") == O.new(Str, "food"))
    assert.is_true("foo" == O.new(Str, "foo"))
    assert.is_false("foo" == O.new(Str, "food"))
    assert.is_true(O.new(Str, "foo") ~= "food")
    assert.is_false(O.new(Str, "foo") < "fo")
    assert.is_false(O.new(Str, "foo") < "foo")
    assert.is_true(O.new(Str, "foo") < "food")
    assert.is_false(O.new(Str, "foo") <= "fo")
    assert.is_true(O.new(Str, "foo") <= "foo")
    assert.is_true(O.new(Str, "foo") <= "food")
    assert.is_true(O.new(Str, "foo") > "fo")
    assert.is_false(O.new(Str, "foo") > "foo")
    assert.is_false(O.new(Str, "foo") > "food")
    assert.is_true(O.new(Str, "foo") >= "fo")
    assert.is_true(O.new(Str, "foo") >= "foo")
    assert.is_false(O.new(Str, "foo") >= "food")
  end)
  
  it("can extract a substring", terra()
    assert.is_true(O.new(Str, "foobar"):sub(3,0) == "bar")
    assert.is_true(O.new(Str, "foobar"):sub(0,3) == "foo")
    assert.is_true(O.new(Str, "foobar"):sub(3,3) == "bar")
    assert.is_true(O.new(Str, "foobar"):sub(3,6) == "bar")
    assert.is_true(O.new(Str, "foobar"):sub(0,90) == "foobar")
    assert.is_true(O.new(Str, "foobar"):sub(0,0) == "foobar")
  end)
  it("can iterate through tokens", terra()
    var s = O.new(Str, "1/2/3/4/5")
    var list = array("1","2","3","4","5")
    var i = 0

    var iter = s:tokens("/")
    for t in iter do
      assert.equal(C.strcmp(list[i], t), 0)
      i = i + 1
    end
  end)
  it("can find characters", terra()
    assert.equal(C.strcmp(O.new(Str, "foobar"):find(("b")[0]), "bar"), 0)
    assert.equal(C.strcmp(O.new(Str, "foobar"):find(("o")[0]), "oobar"), 0)
    assert.equal(C.strcmp(O.new(Str, "foobar"):find(("f")[0]), "foobar"), 0)
    assert.equal(C.strcmp(O.new(Str, "foobar"):findlast(("o")[0]), "obar"), 0)
    assert.equal(C.strcmp(O.new(Str, "foobar"):findlast(("r")[0]), "r"), 0)
  end)
  it("can iterate through characters", terra()
    var s = O.new(Str, "foobar")
    var i = 0
    for c in s:iter() do
      assert.equal(c,("foobar")[i])
      i = i + 1
    end
  end)
  it("can return an upper or lower case version of itself", terra()
    var s = O.new(Str, "FooBar")
    assert.equal(C.strcmp(s:toupper(), "FOOBAR"), 0)
    assert.equal(C.strcmp(s:tolower(), "foobar"), 0)
  end)
  it("can create formatted strings", terra()
    var s = Str.Format("%i %s", 1, "fooBar")
    assert.equal(C.strcmp(s, "1 fooBar"), 0)
  end)
end)
